{"meta":{"title":"LanceBlog","subtitle":"","description":"","author":"Lance","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-10-08T08:54:13.635Z","updated":"2021-10-08T07:35:25.284Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-10-08T08:55:28.609Z","updated":"2021-10-08T07:35:25.283Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-10-08T08:54:13.643Z","updated":"2021-10-08T07:35:25.283Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-10-08T09:41:44.642Z","updated":"2021-10-08T09:41:44.642Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":"https://www.baidu.com"},{"title":"Repositories","date":"2021-10-08T08:54:15.060Z","updated":"2021-10-08T07:35:25.285Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-08T08:54:13.624Z","updated":"2021-10-08T07:35:25.285Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-10-08T08:55:28.591Z","updated":"2021-10-08T07:35:25.281Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""}],"posts":[{"title":"asynq:一个由 Go 开发的轻量级的异步定时任务系统","slug":"asynq:一个由 Go 开发的轻量级的异步定时任务系统","date":"2022-08-23T08:15:31.000Z","updated":"2022-08-23T08:34:47.442Z","comments":true,"path":"2022/08/23/asynq:一个由 Go 开发的轻量级的异步定时任务系统/","link":"","permalink":"http://example.com/2022/08/23/asynq:%E4%B8%80%E4%B8%AA%E7%94%B1%20Go%20%E5%BC%80%E5%8F%91%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"1 安装12go get -u github.com/hibiken/asynqgo get -u github.com/hibiken/asynq/tools/asynqmon 2.使用producer.go将创建并定时要由consumer异步处理的任务。 1234567891011121314151617181920212223242526// 创建asynq连接redis func AsynqServer() &#123; global.AsynqRedis = asynq.NewServer(asynq.RedisClientOpt&#123; Addr: youraddr, Password: yourpassward, // no password set DB: yourdb, // use default DB &#125;, asynq.Config&#123; Concurrency: 50, // 并发树 Queues: map[string]int&#123; &quot;task_queue&quot;: 1, // 队列分配处理时间，此处我只用了一个 &#125;, RetryDelayFunc: func(n int, e error, t *asynq.Task) time.Duration &#123; return 5 * time.Second // 间隔5秒重试 &#125;&#125;)&#125;func AsyncConsumer() &#123; mux := asynq.NewServeMux() mux.HandleFunc(&quot;task_queue&quot;, HandleFraud) // HandleFraud 处理任务队列函数 if err := global.AsynqRedis.Run(mux); err != nil &#123; fmt.Println(&quot;启动正常规则流任务失败&quot;) &#125; fmt.Println(&quot;启动正常规则流任务成功&quot;)&#125; consumer.go 将处理producer创建的任务。 123456789101112//// 即时消费func Test_Enqueue(t *testing.T) &#123; payload, _ := json.Marshal(map[string]interface&#123;&#125;&#123;&quot;uniq_id&quot;: &quot;123456&quot;, &quot;policy_name&quot;: &quot;xw&quot;&#125;) task := asynq.NewTask(&quot;risk:xw:task_queue&quot;, payload, asynq.Retention(3*time.Hour), asynq.MaxRetry(20), asynq.TaskID(&quot;1111&quot;)) // type: risk:xw:task_queue asynq.Retention(3*time.Hour) 结果留存3个小时 asynq.MaxRetry(20) 重试次数20 asynq.TaskID(&quot;1111&quot;) 自定义任务ID res, err := c.Enqueue(task, asynq.Queue(&quot;risk:xw:task_queue&quot;)) if err != nil &#123; t.Errorf(&quot;could not enqueue task: %v&quot;, err) t.FailNow() &#125; fmt.Printf(&quot;Enqueued Result: %+v\\n&quot;, res)&#125; 3.asynqmon 监控3.1安装在github https://github.com/hibiken/asynqmon3.2 使用1asynqmon stats 你应该能看到，有一个任务Enqueued状态，另一个在Scheduled状态。 注意：如需了解每种状态的含义，请参阅Wiki页面上Life of Task。 让我们运行asynqmon与watch命令，以便我们能够连续运行的命令看到的变化。 1watch -n 3 asynqmon stats # Runs `asynqmon stats` every 3 seconds 详情请参考：Asyqn-https://github.com/hibiken/asynq","categories":[],"tags":[{"name":"asynq","slug":"asynq","permalink":"http://example.com/tags/asynq/"}]},{"title":"初级算法","slug":"初级算法","date":"2022-03-23T03:01:32.000Z","updated":"2022-08-23T08:52:13.333Z","comments":true,"path":"2022/03/23/初级算法/","link":"","permalink":"http://example.com/2022/03/23/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/","excerpt":"","text":"1.删除排序数组中的重复项给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums x的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 题解 12345678910class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; for i in range(len(nums)-1,0,-1): if nums[i] == nums[i-1]: del nums[i] return len(nums)","categories":[],"tags":[{"name":"初级算法","slug":"初级算法","permalink":"http://example.com/tags/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/"}]},{"title":"JWT揭秘","slug":"JWT揭秘","date":"2021-10-08T09:06:25.000Z","updated":"2022-08-23T08:02:13.116Z","comments":true,"path":"2021/10/08/JWT揭秘/","link":"","permalink":"http://example.com/2021/10/08/JWT%E6%8F%AD%E7%A7%98/","excerpt":"","text":"docker简介","categories":[{"name":"web相关","slug":"web相关","permalink":"http://example.com/categories/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://example.com/tags/JWT/"}]},{"title":"贷前规则引擎后台管理接口","slug":"贷前规则引擎后台管理接口","date":"2021-08-03T07:46:16.000Z","updated":"2021-10-08T08:32:36.742Z","comments":true,"path":"2021/08/03/贷前规则引擎后台管理接口/","link":"","permalink":"http://example.com/2021/08/03/%E8%B4%B7%E5%89%8D%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"1.通讯协议 Mesh HTTP Json POST 【APPID】 risksystem.xrule_engine.xrule_manager 2.规则流管理2.1 规则流发布提交 URL 1/api/v1.0/flow/publish 请求参数 字段 类型 说明 是否必须 备注 req_id string 流水号 是 唯一流水号 product_id int 产品ID 是 scene_id int 场景ID 是 verson string 规则流版本 是 env_type int 环境类型 是 1为线上环境，2为预发布环境 content string 规则流内容 是 json串 响应数据 字段 类型 说明 是否必须 备注 err_msg string 错误描述 是 version string 服务版本 是 content dict 响应内容 是 err_code int 错误码 是 0为请求成功，非0为请求异常 content字段说明 12345&#123; &#x27;status&#x27;: 1, # 0提交失败，1提交成功，3产品与场景不匹配，4规则流语法错误，5重复提交发布过程中 &#x27;task_id&#x27;: &#x27;4be1a192-ad00-4bd4-94e4-d51748b9a96a&#x27; # 用于跟踪当前发布的流水号&#125; 2.2 规则流发布状态 URL 1/api/v1.0/flow/publish_status 请求参数 字段 类型 说明 是否必须 备注 req_id string 流水号 是 唯一流水号 task_id string 发布流水号 是 响应数据 字段 类型 说明 是否必须 备注 err_code int 错误码 是 0为请求成功，非0为请求异常 err_msg string 错误描述 是 version string 服务版本 是 content dict 响应内容 是 conten字段说明 12345&#123; &#x27;status&#x27;: 1, # 0发布失败，1上线成功，3发布中，4已下线，5未查询到相关记录 &#x27;time&#x27;: &#x27;2020-02-24 12:12:07&#x27; # 事件时间 格式：%Y-%m-%d %H:%M:%S&#125; 2.3 规则流历史发布查询 URL 1/api/v1.0/flow/query 请求参数 字段 类型 说明 是否必须 备注 req_id string 流水号 是 唯一流水号 product_id int 产品ID 是 scene_id int 场景ID 是 verson string 规则流版本 是 响应数据 字段 类型 说明 是否必须 备注 err_code int 错误码 是 0为请求成功，非0为请求异常 err_msg string 错误描述 是 version string 服务版本 是 content list 响应内容 是 conten字段说明 12345678910111213141516171819[ &#123; &#x27;status&#x27;: 1, # 0发布失败，1上线成功，3发布中，4已下线，5未查询到相关记录 &#x27;time&#x27;: &#x27;2020-02-24 12:12:07&#x27;, # 事件时间 格式：%Y-%m-%d %H:%M:%S &#x27;env_type&#x27;: 2, #发布环境 &#x27;task_id&#x27;: &#x27;78c85e91-8c7c-499e-8df3-1466a58192b6&#x27; # 发布的流水号 &#x27;version&#x27;: &#x27;success_node&#x27;:[&#x27;127.0.0.1&#x27;] &#x27;failed_node&#x27;:[] &#125;, &#123; &#x27;status&#x27;: 1, # 0发布失败，1上线成功，3发布中，4已下线，5未查询到相关记录 &#x27;time&#x27;: &#x27;2020-02-24 15:45:09&#x27;, # 事件时间 格式：%Y-%m-%d %H:%M:%S &#x27;env_type&#x27;: 1, #发布环境 &#x27;task_id&#x27;: &#x27;4be1a192-ad00-4bd4-94e4-d51748b9a96a&#x27; # 发布的流水号 &#x27;success_node&#x27;:[&#x27;127.0.0.1&#x27;] &#x27;failed_node&#x27;:[] &#125;] 2.4 规则流验证 URL 1/api/v1.0/flow/check 请求参数 字段 类型 说明 是否必须 备注 req_id string 流水号 是 唯一流水号 product_id int 产品ID 是 scene_id int 场景ID 是 verson string 规则流版本 是 响应数据 字段 类型 说明 是否必须 备注 err_code int 错误码 是 err_msg string 错误描述 是 version string 服务版本 是 err_code字段说明 err_code 说明 0 规则流正确 &lt; 0 服务异常 1 无版本号 ‘’ 2 空节点 没有name 3 节点名重复 name:uniq 4 节点定义未被使用 5 边无定义action 没有传None 6 无开始节点 无 7 多个初始节点 多个图 8 无未命中输出线 所有边 9 模块和流END节点 无 web限制最多一个END 10 相同src, 相同action不同输出节点 无 11 节点的输出线无覆盖规则本身执行操作 包含模块 12 决策流有环 3.常量操作3.1 常量操作 URL 1/api/v1.0/constant/operate 请求参数 字段 类型 说明 是否必须 备注 req_id string 流水号 是 唯一流水号 constant_en_name string 变量名称 是 constant_type string 变量类型 是 constant_value string 变量参数 是 json串，数字字符串原样传输 响应数据 字段 类型 说明 是否必须 备注 err_code int 错误码 是 0为请求成功，非0为请求异常 err_msg string 错误描述 是","categories":[],"tags":[]}],"categories":[{"name":"web相关","slug":"web相关","permalink":"http://example.com/categories/web%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"asynq","slug":"asynq","permalink":"http://example.com/tags/asynq/"},{"name":"初级算法","slug":"初级算法","permalink":"http://example.com/tags/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/"},{"name":"JWT","slug":"JWT","permalink":"http://example.com/tags/JWT/"}]}